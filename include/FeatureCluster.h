//
// Created by gengshuai on 19-12-9.
//
/*
 *该函数定义了回环检测的函数
 */

#ifndef TSDF_FEATURECLUSTER_H
#define TSDF_FEATURECLUSTER_H

#include "DBoW3/DBoW3.h"
#include <opencv2/core/core.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/features2d/features2d.hpp>
#include <iostream>
#include <vector>
#include <string>


namespace ark {

    class Vocabulary {
    public:
        Vocabulary();

        bool addDescriptor(const cv::Mat &des);

        bool createVocabulary();

        bool calculateBowVec();

        int calculateNN(const cv::Mat &des);

        DBoW3::Vocabulary vocab;

        std::vector<DBoW3::BowVector> bowVector;
        std::vector<cv::Mat> descriptors;
    };


}
//
//int main( int argc, char** argv )
//{
//    // read the image
//    cout<<"reading images... "<<endl;
//    vector<Mat> images;
//    for ( int i=0; i<10; i++ )
//    {
//        string path = "./data/"+to_string(i+1)+".png";
//        images.push_back( imread(path) );
//    }
//    // detect ORB features
//    cout<<"detecting ORB features ... "<<endl;
//    Ptr< Feature2D > detector = ORB::create();
//    vector<Mat> descriptors;
//    for ( Mat& image:images )
//    {
//        vector<KeyPoint> keypoints;
//        Mat descriptor;
//        detector->detectAndCompute( image, Mat(), keypoints, descriptor );
//        descriptors.push_back( descriptor );
//    }
//
//    // create vocabulary
//    cout<<"creating vocabulary ... "<<endl;
//
//    vocab.create(descriptors);
//    cout<<"vocabulary info: "<<vocab<<endl;
//    vocab.save( "vocabulary.yml.gz" );
//    cout<<"done"<<endl;
//
//    return 0;
//}
//
//
//
//int main( int argc, char** argv )
//{
//    // read the images and database
//    cout<<"reading database"<<endl;
//    DBoW3::Vocabulary vocab("./vocabulary.yml.gz");
//    // DBoW3::Vocabulary vocab("./vocab_larger.yml.gz");  // use large vocab if you want:
//    if ( vocab.empty() )
//    {
//        cerr<<"Vocabulary does not exist."<<endl;
//        return 1;
//    }
//    cout<<"reading images... "<<endl;
//    vector<Mat> images;
//    for ( int i=0; i<10; i++ )
//    {
//        string path = "./data/"+to_string(i+1)+".png";
//        images.push_back( imread(path) );
//    }
//
//    // NOTE: in this case we are comparing images with a vocabulary generated by themselves, this may leed to overfitting.
//    // detect ORB features
//    cout<<"detecting ORB features ... "<<endl;
//    Ptr< Feature2D > detector = ORB::create();
//    vector<Mat> descriptors;
//    for ( Mat& image:images )
//    {
//        vector<KeyPoint> keypoints;
//        Mat descriptor;
//        detector->detectAndCompute( image, Mat(), keypoints, descriptor );
//        descriptors.push_back( descriptor );
//    }
//
//    // we can compare the images directly or we can compare one image to a database
//    // images :
//    cout<<"comparing images with images "<<endl;
//    for ( int i=0; i<images.size(); i++ )
//    {
//        DBoW3::BowVector v1;
//        vocab.transform( descriptors[i], v1 );
//        for ( int j=i; j<images.size(); j++ )
//        {
//            DBoW3::BowVector v2;
//            vocab.transform( descriptors[j], v2 );
//            double score = vocab.score(v1, v2);
//            cout<<"image "<<i<<" vs image "<<j<<" : "<<score<<endl;
//        }
//        cout<<endl;
//    }
//
//    // or with database
//    cout<<"comparing images with database "<<endl;
//    DBoW3::Database db( vocab, false, 0);
//    for ( int i=0; i<descriptors.size(); i++ )
//        db.add(descriptors[i]);
//    cout<<"database info: "<<db<<endl;
//    for ( int i=0; i<descriptors.size(); i++ )
//    {
//        DBoW3::QueryResults ret;
//        db.query( descriptors[i], ret, 4);      // max result=4
//        cout<<"searching for image "<<i<<" returns "<<ret<<endl<<endl;
//    }
//    cout<<"done."<<endl;
//}

#endif //TSDF_FEATURECLUSTER_H
